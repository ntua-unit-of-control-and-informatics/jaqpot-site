# jaqpotpy.api.openapi.models package

## Submodules

## jaqpotpy.api.openapi.models.api_key module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.api_key.ApiKey(\*, clientKey: Annotated[str, Strict(strict=True)] | None = None, note: Annotated[str, Strict(strict=True)] | None = None, userId: Annotated[str, Strict(strict=True)] | None = None, expiresAt: datetime | None = None, expirationTime: Annotated[str, Strict(strict=True)], lastUsed: datetime | None = None, lastUsedIp: Annotated[str, Strict(strict=True)] | None = None, enabled: Annotated[bool, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### client_key *: StrictStr | None*

#### enabled *: StrictBool | None*

#### expiration_time *: StrictStr*

#### *classmethod* expiration_time_validate_enum(value)

Validates the enum

#### expires_at *: datetime | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of ApiKey from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of ApiKey from a JSON string

#### last_used *: datetime | None*

#### last_used_ip *: StrictStr | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'client_key': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='clientKey', alias_priority=2, description='The generated API key'), 'enabled': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, description='Whether the API key is active or disabled'), 'expiration_time': FieldInfo(annotation=str, required=True, alias='expirationTime', alias_priority=2, metadata=[Strict(strict=True)]), 'expires_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='expiresAt', alias_priority=2, description='The expiration time of the API key (if any)'), 'last_used': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='lastUsed', alias_priority=2, description='The last time the API key was used'), 'last_used_ip': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='lastUsedIp', alias_priority=2, description='The IP address from which the API key was last used'), 'note': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='A note for the API key'), 'user_id': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='userId', alias_priority=2, description='The ID of the user associated with the API key')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### note *: StrictStr | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### user_id *: StrictStr | None*

## jaqpotpy.api.openapi.models.binary_classification_scores module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.binary_classification_scores.BinaryClassificationScores(\*, labels: List[Annotated[str, Strict(strict=True)]] | None = None, yName: Annotated[str, Strict(strict=True)], folds: Annotated[int, Strict(strict=True)] | None = None, accuracy: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, balancedAccuracy: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, precision: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, recall: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, f1Score: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, jaccard: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, matthewsCorrCoef: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, confusionMatrix: Annotated[List[Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])] | None = None)

Bases: `BaseModel`

#### accuracy *: StrictFloat | StrictInt | None*

#### balanced_accuracy *: StrictFloat | StrictInt | None*

#### confusion_matrix *: Annotated[List[Annotated[List[StrictFloat | StrictInt], Field(max_length=100)]], Field(max_length=100)] | None*

#### f1_score *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### folds *: StrictInt | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of BinaryClassificationScores from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of BinaryClassificationScores from a JSON string

#### jaccard *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### labels *: List[StrictStr] | None*

#### matthews_corr_coef *: StrictFloat | StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'accuracy': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'balanced_accuracy': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='balancedAccuracy', alias_priority=2), 'confusion_matrix': FieldInfo(annotation=Union[Annotated[List[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])], NoneType], required=False, default=None, alias='confusionMatrix', alias_priority=2), 'f1_score': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None, alias='f1Score', alias_priority=2), 'folds': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'jaccard': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'labels': FieldInfo(annotation=Union[List[Annotated[str, Strict(strict=True)]], NoneType], required=False, default=None), 'matthews_corr_coef': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='matthewsCorrCoef', alias_priority=2), 'precision': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'recall': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'y_name': FieldInfo(annotation=str, required=True, alias='yName', alias_priority=2, metadata=[Strict(strict=True)])}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### precision *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### recall *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### y_name *: StrictStr*

## jaqpotpy.api.openapi.models.bounding_box_doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.bounding_box_doa.BoundingBoxDoa(\*, boundingBox: List[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]]] | None = None)

Bases: `BaseModel`

#### bounding_box *: List[List[StrictFloat | StrictInt]] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of BoundingBoxDoa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of BoundingBoxDoa from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'bounding_box': FieldInfo(annotation=Union[List[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]]], NoneType], required=False, default=None, alias='boundingBox', alias_priority=2)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.city_block_doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.city_block_doa.CityBlockDoa(\*, data: Dict[str, Any] | None = None)

Bases: `BaseModel`

#### data *: Dict[str, Any] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of CityBlockDoa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of CityBlockDoa from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'data': FieldInfo(annotation=Union[Dict[str, Any], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.create_api_key201_response module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.create_api_key201_response.CreateApiKey201Response(\*, clientKey: Annotated[str, Strict(strict=True)] | None = None, clientSecret: Annotated[str, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### client_key *: StrictStr | None*

#### client_secret *: StrictStr | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of CreateApiKey201Response from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of CreateApiKey201Response from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'client_key': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='clientKey', alias_priority=2, description='The generated API key'), 'client_secret': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='clientSecret', alias_priority=2, description='The generated API secret')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.create_invitations_request module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.create_invitations_request.CreateInvitationsRequest(\*, emails: Annotated[List[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MinLen(min_length=1), MaxLen(max_length=10)])] | None = None)

Bases: `BaseModel`

#### emails *: Annotated[List[StrictStr], Field(min_length=1, max_length=10)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of CreateInvitationsRequest from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of CreateInvitationsRequest from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'emails': FieldInfo(annotation=Union[Annotated[List[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MinLen(min_length=1), MaxLen(max_length=10)])], NoneType], required=False, default=None, description='List of email addresses to invite')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.dataset module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.dataset.Dataset(\*, id: Annotated[int, Strict(strict=True)] | None = None, type: [DatasetType](#jaqpotpy.api.openapi.models.dataset_type.DatasetType), entryType: Annotated[str, Strict(strict=True)], input: Annotated[List[Any], MaxLen(max_length=100)], result: List[Any] | None = None, status: Annotated[str, Strict(strict=True)] | None = None, failureReason: Annotated[str, Strict(strict=True)] | None = None, userId: Annotated[str, Strict(strict=True)] | None = None, modelId: Annotated[int, Strict(strict=True)] | None = None, modelName: Annotated[str, Strict(strict=True)] | None = None, executedAt: datetime | None = None, executionFinishedAt: datetime | None = None, createdAt: datetime | None = None, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### created_at *: datetime | None*

#### entry_type *: StrictStr*

#### *classmethod* entry_type_validate_enum(value)

Validates the enum

#### executed_at *: datetime | None*

#### execution_finished_at *: datetime | None*

#### failure_reason *: StrictStr | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Dataset from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Dataset from a JSON string

#### id *: StrictInt | None*

#### input *: Annotated[List[Any], Field(max_length=100)]*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2), 'entry_type': FieldInfo(annotation=str, required=True, alias='entryType', alias_priority=2, metadata=[Strict(strict=True)]), 'executed_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='executedAt', alias_priority=2), 'execution_finished_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='executionFinishedAt', alias_priority=2), 'failure_reason': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='failureReason', alias_priority=2), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'input': FieldInfo(annotation=List[Any], required=True, metadata=[MaxLen(max_length=100)]), 'model_id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='modelId', alias_priority=2), 'model_name': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='modelName', alias_priority=2), 'result': FieldInfo(annotation=Union[List[Any], NoneType], required=False, default=None), 'status': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'type': FieldInfo(annotation=DatasetType, required=True), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2), 'user_id': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='userId', alias_priority=2)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_id *: StrictInt | None*

#### model_name *: StrictStr | None*

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### result *: List[Any] | None*

#### status *: StrictStr | None*

#### *classmethod* status_validate_enum(value)

Validates the enum

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### type *: [DatasetType](#jaqpotpy.api.openapi.models.dataset_type.DatasetType)*

#### updated_at *: datetime | None*

#### user_id *: StrictStr | None*

## jaqpotpy.api.openapi.models.dataset_csv module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.dataset_csv.DatasetCSV(\*, id: Annotated[int, Strict(strict=True)] | None = None, type: [DatasetType](#jaqpotpy.api.openapi.models.dataset_type.DatasetType), inputFile: Annotated[bytes, Strict(strict=True)] | Annotated[str, Strict(strict=True)], values: List[Any] | None = None, status: Annotated[str, Strict(strict=True)] | None = None, failureReason: Annotated[str, Strict(strict=True)] | None = None, modelId: Annotated[int, Strict(strict=True)] | None = None, modelName: Annotated[str, Strict(strict=True)] | None = None, executedAt: datetime | None = None, executionFinishedAt: datetime | None = None, createdAt: datetime | None = None, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### created_at *: datetime | None*

#### executed_at *: datetime | None*

#### execution_finished_at *: datetime | None*

#### failure_reason *: StrictStr | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of DatasetCSV from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of DatasetCSV from a JSON string

#### id *: StrictInt | None*

#### input_file *: StrictBytes | StrictStr*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2), 'executed_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='executedAt', alias_priority=2), 'execution_finished_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='executionFinishedAt', alias_priority=2), 'failure_reason': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='failureReason', alias_priority=2), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'input_file': FieldInfo(annotation=Union[Annotated[bytes, Strict(strict=True)], Annotated[str, Strict(strict=True)]], required=True, alias='inputFile', alias_priority=2, description='A base64 representation in CSV format of the input values.'), 'model_id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='modelId', alias_priority=2), 'model_name': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='modelName', alias_priority=2), 'status': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'type': FieldInfo(annotation=DatasetType, required=True), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2), 'values': FieldInfo(annotation=Union[List[Any], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_id *: StrictInt | None*

#### model_name *: StrictStr | None*

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### status *: StrictStr | None*

#### *classmethod* status_validate_enum(value)

Validates the enum

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### type *: [DatasetType](#jaqpotpy.api.openapi.models.dataset_type.DatasetType)*

#### updated_at *: datetime | None*

#### values *: List[Any] | None*

## jaqpotpy.api.openapi.models.dataset_type module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.dataset_type.DatasetType(value)

Bases: `str`, `Enum`

#### PREDICTION *= 'PREDICTION'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of DatasetType from a JSON string

## jaqpotpy.api.openapi.models.doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.doa.Doa(\*, id: Annotated[int, Strict(strict=True)] | None = None, method: [DoaMethod](#jaqpotpy.api.openapi.models.doa_method.DoaMethod), data: Dict[str, Any], createdAt: datetime | None = None, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### created_at *: datetime | None*

#### data *: Dict[str, Any]*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Doa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Doa from a JSON string

#### id *: StrictInt | None*

#### method *: [DoaMethod](#jaqpotpy.api.openapi.models.doa_method.DoaMethod)*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2, description='The date and time when the feature was created.'), 'data': FieldInfo(annotation=Dict[str, Any], required=True), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'method': FieldInfo(annotation=DoaMethod, required=True), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2, description='The date and time when the feature was last updated.')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### updated_at *: datetime | None*

## jaqpotpy.api.openapi.models.doa_method module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.doa_method.DoaMethod(value)

Bases: `str`, `Enum`

#### BOUNDING_BOX *= 'BOUNDING_BOX'*

#### CITY_BLOCK *= 'CITY_BLOCK'*

#### KERNEL_BASED *= 'KERNEL_BASED'*

#### LEVERAGE *= 'LEVERAGE'*

#### MAHALANOBIS *= 'MAHALANOBIS'*

#### MEAN_VAR *= 'MEAN_VAR'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of DoaMethod from a JSON string

## jaqpotpy.api.openapi.models.error_code module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.error_code.ErrorCode(value)

Bases: `str`, `Enum`

#### ENUM_1001 *= '1001'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of ErrorCode from a JSON string

## jaqpotpy.api.openapi.models.error_response module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.error_response.ErrorResponse(\*, message: Annotated[str, Strict(strict=True)] | None = None, code: Annotated[int, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### code *: StrictInt | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of ErrorResponse from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of ErrorResponse from a JSON string

#### message *: StrictStr | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'code': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, description='Error code'), 'message': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='Error message')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.feature module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.feature.Feature(\*, id: Annotated[int, Strict(strict=True)] | None = None, key: Annotated[str, Strict(strict=True)], name: Annotated[str, Strict(strict=True), MaxLen(max_length=255)], units: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=255)])] | None = None, range: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=255)])] | None = None, description: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=2000)])] | None = None, featureType: [FeatureType](#jaqpotpy.api.openapi.models.feature_type.FeatureType), featureDependency: Annotated[str, Strict(strict=True)] | None = None, visible: Annotated[bool, Strict(strict=True)] | None = None, possibleValues: Annotated[List[[FeaturePossibleValue](#jaqpotpy.api.openapi.models.feature_possible_value.FeaturePossibleValue)], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, createdAt: datetime | None = None, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### created_at *: datetime | None*

#### description *: Annotated[str, Field(strict=True, max_length=2000)] | None*

#### feature_dependency *: StrictStr | None*

#### *classmethod* feature_dependency_validate_enum(value)

Validates the enum

#### feature_type *: [FeatureType](#jaqpotpy.api.openapi.models.feature_type.FeatureType)*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Feature from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Feature from a JSON string

#### id *: StrictInt | None*

#### key *: StrictStr*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2, description='The date and time when the feature was created.'), 'description': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=2000)])], NoneType], required=False, default=None), 'feature_dependency': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='featureDependency', alias_priority=2), 'feature_type': FieldInfo(annotation=FeatureType, required=True, alias='featureType', alias_priority=2), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'key': FieldInfo(annotation=str, required=True, description="A key that must start with a letter, followed by any combination of letters, digits, hyphens, or underscores. For example, 'abc123', 'abc-test', or 'Abc_test'. It cannot start with a digit.", metadata=[Strict(strict=True)]), 'name': FieldInfo(annotation=str, required=True, description='A name for the feature that will appear on top of the form field', metadata=[Strict(strict=True), MaxLen(max_length=255)]), 'possible_values': FieldInfo(annotation=Union[Annotated[List[FeaturePossibleValue], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None, alias='possibleValues', alias_priority=2), 'range': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=255)])], NoneType], required=False, default=None, description='The range for the feature'), 'units': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=255)])], NoneType], required=False, default=None, description='The units for the feature'), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2, description='The date and time when the feature was last updated.'), 'visible': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: Annotated[str, Field(strict=True, max_length=255)]*

#### possible_values *: Annotated[List[[FeaturePossibleValue](#jaqpotpy.api.openapi.models.feature_possible_value.FeaturePossibleValue)], Field(max_length=1000)] | None*

#### range *: Annotated[str, Field(strict=True, max_length=255)] | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### units *: Annotated[str, Field(strict=True, max_length=255)] | None*

#### updated_at *: datetime | None*

#### visible *: StrictBool | None*

## jaqpotpy.api.openapi.models.feature_possible_value module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.feature_possible_value.FeaturePossibleValue(\*, key: Annotated[str, Strict(strict=True)], value: Annotated[str, Strict(strict=True)])

Bases: `BaseModel`

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of FeaturePossibleValue from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of FeaturePossibleValue from a JSON string

#### key *: StrictStr*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'key': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)]), 'value': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)])}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### value *: StrictStr*

## jaqpotpy.api.openapi.models.feature_type module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.feature_type.FeatureType(value)

Bases: `str`, `Enum`

#### CATEGORICAL *= 'CATEGORICAL'*

#### FLOAT *= 'FLOAT'*

#### FLOAT_ARRAY *= 'FLOAT_ARRAY'*

#### INTEGER *= 'INTEGER'*

#### SMILES *= 'SMILES'*

#### STRING *= 'STRING'*

#### STRING_ARRAY *= 'STRING_ARRAY'*

#### TEXT *= 'TEXT'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of FeatureType from a JSON string

## jaqpotpy.api.openapi.models.get_all_api_keys_for_user200_response_inner module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.get_all_api_keys_for_user200_response_inner.GetAllApiKeysForUser200ResponseInner(\*, clientKey: Annotated[str, Strict(strict=True)] | None = None, note: Annotated[str, Strict(strict=True)] | None = None, createdAt: datetime | None = None, expiresAt: datetime | None = None, enabled: Annotated[bool, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### client_key *: StrictStr | None*

#### created_at *: datetime | None*

#### enabled *: StrictBool | None*

#### expires_at *: datetime | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of GetAllApiKeysForUser200ResponseInner from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of GetAllApiKeysForUser200ResponseInner from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'client_key': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='clientKey', alias_priority=2, description='The API key'), 'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2, description='Creation timestamp of the API key'), 'enabled': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, description='Whether the API key is active or disabled'), 'expires_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='expiresAt', alias_priority=2, description='Expiration timestamp of the API key (optional)'), 'note': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='Description of the API key')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### note *: StrictStr | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.get_datasets200_response module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.get_datasets200_response.GetDatasets200Response(\*, content: List[[Dataset](#jaqpotpy.api.openapi.models.dataset.Dataset)] | None = None, totalElements: Annotated[int, Strict(strict=True)] | None = None, totalPages: Annotated[int, Strict(strict=True)] | None = None, pageSize: Annotated[int, Strict(strict=True)] | None = None, pageNumber: Annotated[int, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### content *: List[[Dataset](#jaqpotpy.api.openapi.models.dataset.Dataset)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of GetDatasets200Response from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of GetDatasets200Response from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'content': FieldInfo(annotation=Union[List[Dataset], NoneType], required=False, default=None), 'page_number': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='pageNumber', alias_priority=2), 'page_size': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='pageSize', alias_priority=2), 'total_elements': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='totalElements', alias_priority=2), 'total_pages': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='totalPages', alias_priority=2)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### page_number *: StrictInt | None*

#### page_size *: StrictInt | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### total_elements *: StrictInt | None*

#### total_pages *: StrictInt | None*

## jaqpotpy.api.openapi.models.get_models200_response module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.get_models200_response.GetModels200Response(\*, content: List[[ModelSummary](#jaqpotpy.api.openapi.models.model_summary.ModelSummary)] | None = None, totalElements: Annotated[int, Strict(strict=True)] | None = None, totalPages: Annotated[int, Strict(strict=True)] | None = None, pageSize: Annotated[int, Strict(strict=True)] | None = None, pageNumber: Annotated[int, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### content *: List[[ModelSummary](#jaqpotpy.api.openapi.models.model_summary.ModelSummary)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of GetModels200Response from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of GetModels200Response from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'content': FieldInfo(annotation=Union[List[ModelSummary], NoneType], required=False, default=None), 'page_number': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='pageNumber', alias_priority=2), 'page_size': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='pageSize', alias_priority=2), 'total_elements': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='totalElements', alias_priority=2), 'total_pages': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='totalPages', alias_priority=2)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### page_number *: StrictInt | None*

#### page_size *: StrictInt | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### total_elements *: StrictInt | None*

#### total_pages *: StrictInt | None*

## jaqpotpy.api.openapi.models.kernel_based_doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.kernel_based_doa.KernelBasedDoa(\*, data: Dict[str, Any] | None = None)

Bases: `BaseModel`

#### data *: Dict[str, Any] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of KernelBasedDoa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of KernelBasedDoa from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'data': FieldInfo(annotation=Union[Dict[str, Any], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.lead module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.lead.Lead(\*, id: Annotated[int, Strict(strict=True)] | None = None, email: Annotated[str, Strict(strict=True)] | None = None, name: Annotated[str, Strict(strict=True)] | None = None, status: Annotated[str, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### email *: StrictStr | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Lead from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Lead from a JSON string

#### id *: StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'email': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'name': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'status': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: StrictStr | None*

#### status *: StrictStr | None*

#### *classmethod* status_validate_enum(value)

Validates the enum

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.leverage_doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.leverage_doa.LeverageDoa(\*, hStar: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, doaMatrix: List[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]]] | None = None)

Bases: `BaseModel`

#### doa_matrix *: List[List[StrictFloat | StrictInt]] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of LeverageDoa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of LeverageDoa from a JSON string

#### h_star *: StrictFloat | StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'doa_matrix': FieldInfo(annotation=Union[List[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]]], NoneType], required=False, default=None, alias='doaMatrix', alias_priority=2), 'h_star': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='hStar', alias_priority=2)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.library module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.library.Library(\*, id: Annotated[int, Strict(strict=True)] | None = None, name: Annotated[str, Strict(strict=True)], version: Annotated[str, Strict(strict=True)], createdAt: datetime | None = None, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### created_at *: datetime | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Library from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Library from a JSON string

#### id *: StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2, description='The date and time when the feature was created.'), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)]), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2, description='The date and time when the feature was last updated.'), 'version': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)])}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: StrictStr*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### updated_at *: datetime | None*

#### version *: StrictStr*

## jaqpotpy.api.openapi.models.mahalanobis_doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.mahalanobis_doa.MahalanobisDoa(\*, data: Dict[str, Any] | None = None)

Bases: `BaseModel`

#### data *: Dict[str, Any] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of MahalanobisDoa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of MahalanobisDoa from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'data': FieldInfo(annotation=Union[Dict[str, Any], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.mean_var_doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.mean_var_doa.MeanVarDoa(\*, bounds: List[Annotated[List[Annotated[float, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True)])] | Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True)])]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])]] | None = None)

Bases: `BaseModel`

#### bounds *: List[Annotated[List[Annotated[float, Field(strict=True)] | Annotated[int, Field(strict=True)]], Field(max_length=1000)]] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of MeanVarDoa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of MeanVarDoa from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'bounds': FieldInfo(annotation=Union[List[Annotated[List[Union[Annotated[float, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True)])], Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True)])]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])]], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.model module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.model.Model(\*, id: Annotated[int, Strict(strict=True)] | None = None, name: Annotated[str, Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=255)], description: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=50000)])] | None = None, type: [ModelType](#jaqpotpy.api.openapi.models.model_type.ModelType), jaqpotpyVersion: Annotated[str, Strict(strict=True)], doas: Annotated[List[[Doa](#jaqpotpy.api.openapi.models.doa.Doa)], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=50)])] | None = None, libraries: Annotated[List[[Library](#jaqpotpy.api.openapi.models.library.Library)], MaxLen(max_length=1000)], dependentFeatures: Annotated[List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)], MaxLen(max_length=1000)], independentFeatures: Annotated[List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)], MaxLen(max_length=1000)], sharedWithOrganizations: List[[Organization](#jaqpotpy.api.openapi.models.organization.Organization)] | None = None, visibility: [ModelVisibility](#jaqpotpy.api.openapi.models.model_visibility.ModelVisibility), task: [ModelTask](#jaqpotpy.api.openapi.models.model_task.ModelTask), torchConfig: Dict[str, Any] | None = None, preprocessors: Annotated[List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=50)])] | None = None, featurizers: Annotated[List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=50)])] | None = None, rawPreprocessor: Annotated[bytes, Strict(strict=True)] | Annotated[str, Strict(strict=True)] | None = None, rawModel: Annotated[bytes, Strict(strict=True)] | Annotated[str, Strict(strict=True)], creator: [User](#jaqpotpy.api.openapi.models.user.User) | None = None, canEdit: Annotated[bool, Strict(strict=True)] | None = None, isAdmin: Annotated[bool, Strict(strict=True)] | None = None, selectedFeatures: Annotated[List[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, tags: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=1000)])] | None = None, legacyPredictionService: Annotated[str, Strict(strict=True)] | None = None, scores: [ModelScores](#jaqpotpy.api.openapi.models.model_scores.ModelScores) | None = None, createdAt: datetime | None = None, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### can_edit *: StrictBool | None*

#### created_at *: datetime | None*

#### creator *: [User](#jaqpotpy.api.openapi.models.user.User) | None*

#### dependent_features *: Annotated[List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)], Field(max_length=1000)]*

#### description *: Annotated[str, Field(min_length=3, strict=True, max_length=50000)] | None*

#### doas *: Annotated[List[[Doa](#jaqpotpy.api.openapi.models.doa.Doa)], Field(max_length=50)] | None*

#### featurizers *: Annotated[List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)], Field(max_length=50)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Model from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Model from a JSON string

#### id *: StrictInt | None*

#### independent_features *: Annotated[List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)], Field(max_length=1000)]*

#### is_admin *: StrictBool | None*

#### jaqpotpy_version *: StrictStr*

#### legacy_prediction_service *: StrictStr | None*

#### libraries *: Annotated[List[[Library](#jaqpotpy.api.openapi.models.library.Library)], Field(max_length=1000)]*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'can_edit': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, alias='canEdit', alias_priority=2, description='If the current user can edit the model'), 'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2, description='The date and time when the feature was created.'), 'creator': FieldInfo(annotation=Union[User, NoneType], required=False, default=None), 'dependent_features': FieldInfo(annotation=List[Feature], required=True, alias='dependentFeatures', alias_priority=2, metadata=[MaxLen(max_length=1000)]), 'description': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=50000)])], NoneType], required=False, default=None), 'doas': FieldInfo(annotation=Union[Annotated[List[Doa], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=50)])], NoneType], required=False, default=None), 'featurizers': FieldInfo(annotation=Union[Annotated[List[Transformer], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=50)])], NoneType], required=False, default=None), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'independent_features': FieldInfo(annotation=List[Feature], required=True, alias='independentFeatures', alias_priority=2, metadata=[MaxLen(max_length=1000)]), 'is_admin': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, alias='isAdmin', alias_priority=2), 'jaqpotpy_version': FieldInfo(annotation=str, required=True, alias='jaqpotpyVersion', alias_priority=2, metadata=[Strict(strict=True)]), 'legacy_prediction_service': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='legacyPredictionService', alias_priority=2), 'libraries': FieldInfo(annotation=List[Library], required=True, metadata=[MaxLen(max_length=1000)]), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=255)]), 'preprocessors': FieldInfo(annotation=Union[Annotated[List[Transformer], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=50)])], NoneType], required=False, default=None), 'raw_model': FieldInfo(annotation=Union[Annotated[bytes, Strict(strict=True)], Annotated[str, Strict(strict=True)]], required=True, alias='rawModel', alias_priority=2, description='A base64 representation of the raw model.'), 'raw_preprocessor': FieldInfo(annotation=Union[Annotated[bytes, Strict(strict=True)], Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='rawPreprocessor', alias_priority=2, description='A base64 representation of the raw preprocessor.'), 'scores': FieldInfo(annotation=Union[ModelScores, NoneType], required=False, default=None), 'selected_features': FieldInfo(annotation=Union[Annotated[List[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None, alias='selectedFeatures', alias_priority=2), 'shared_with_organizations': FieldInfo(annotation=Union[List[Organization], NoneType], required=False, default=None, alias='sharedWithOrganizations', alias_priority=2), 'tags': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'task': FieldInfo(annotation=ModelTask, required=True), 'torch_config': FieldInfo(annotation=Union[Dict[str, Any], NoneType], required=False, default=None, alias='torchConfig', alias_priority=2), 'type': FieldInfo(annotation=ModelType, required=True), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2, description='The date and time when the feature was last updated.'), 'visibility': FieldInfo(annotation=ModelVisibility, required=True)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: Annotated[str, Field(min_length=3, strict=True, max_length=255)]*

#### preprocessors *: Annotated[List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)], Field(max_length=50)] | None*

#### raw_model *: StrictBytes | StrictStr*

#### raw_preprocessor *: StrictBytes | StrictStr | None*

#### scores *: [ModelScores](#jaqpotpy.api.openapi.models.model_scores.ModelScores) | None*

#### selected_features *: Annotated[List[StrictStr], Field(max_length=1000)] | None*

#### shared_with_organizations *: List[[Organization](#jaqpotpy.api.openapi.models.organization.Organization)] | None*

#### tags *: Annotated[str, Field(strict=True, max_length=1000)] | None*

#### task *: [ModelTask](#jaqpotpy.api.openapi.models.model_task.ModelTask)*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### torch_config *: Dict[str, Any] | None*

#### type *: [ModelType](#jaqpotpy.api.openapi.models.model_type.ModelType)*

#### updated_at *: datetime | None*

#### visibility *: [ModelVisibility](#jaqpotpy.api.openapi.models.model_visibility.ModelVisibility)*

## jaqpotpy.api.openapi.models.model_scores module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.model_scores.ModelScores(\*, train: List[[Scores](#jaqpotpy.api.openapi.models.scores.Scores)] | None = None, test: List[[Scores](#jaqpotpy.api.openapi.models.scores.Scores)] | None = None, crossValidation: List[[Scores](#jaqpotpy.api.openapi.models.scores.Scores)] | None = None)

Bases: `BaseModel`

#### cross_validation *: List[[Scores](#jaqpotpy.api.openapi.models.scores.Scores)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of ModelScores from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of ModelScores from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'cross_validation': FieldInfo(annotation=Union[List[Scores], NoneType], required=False, default=None, alias='crossValidation', alias_priority=2), 'test': FieldInfo(annotation=Union[List[Scores], NoneType], required=False, default=None), 'train': FieldInfo(annotation=Union[List[Scores], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### test *: List[[Scores](#jaqpotpy.api.openapi.models.scores.Scores)] | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### train *: List[[Scores](#jaqpotpy.api.openapi.models.scores.Scores)] | None*

## jaqpotpy.api.openapi.models.model_summary module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.model_summary.ModelSummary(\*, id: Annotated[int, Strict(strict=True)], name: Annotated[str, Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=255)], visibility: [ModelVisibility](#jaqpotpy.api.openapi.models.model_visibility.ModelVisibility), description: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=50000)])] | None = None, creator: [User](#jaqpotpy.api.openapi.models.user.User) | None = None, type: [ModelType](#jaqpotpy.api.openapi.models.model_type.ModelType), dependentFeaturesLength: Annotated[int, Strict(strict=True)] | None = None, independentFeaturesLength: Annotated[int, Strict(strict=True)] | None = None, sharedWithOrganizations: List[[OrganizationSummary](#jaqpotpy.api.openapi.models.organization_summary.OrganizationSummary)], createdAt: datetime, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### created_at *: datetime*

#### creator *: [User](#jaqpotpy.api.openapi.models.user.User) | None*

#### dependent_features_length *: StrictInt | None*

#### description *: Annotated[str, Field(min_length=3, strict=True, max_length=50000)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of ModelSummary from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of ModelSummary from a JSON string

#### id *: StrictInt*

#### independent_features_length *: StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'created_at': FieldInfo(annotation=datetime, required=True, alias='createdAt', alias_priority=2, description='The date and time when the feature was created.'), 'creator': FieldInfo(annotation=Union[User, NoneType], required=False, default=None), 'dependent_features_length': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='dependentFeaturesLength', alias_priority=2), 'description': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=50000)])], NoneType], required=False, default=None), 'id': FieldInfo(annotation=int, required=True, metadata=[Strict(strict=True)]), 'independent_features_length': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='independentFeaturesLength', alias_priority=2), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=255)]), 'shared_with_organizations': FieldInfo(annotation=List[OrganizationSummary], required=True, alias='sharedWithOrganizations', alias_priority=2), 'type': FieldInfo(annotation=ModelType, required=True), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2, description='The date and time when the feature was last updated.'), 'visibility': FieldInfo(annotation=ModelVisibility, required=True)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: Annotated[str, Field(min_length=3, strict=True, max_length=255)]*

#### shared_with_organizations *: List[[OrganizationSummary](#jaqpotpy.api.openapi.models.organization_summary.OrganizationSummary)]*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### type *: [ModelType](#jaqpotpy.api.openapi.models.model_type.ModelType)*

#### updated_at *: datetime | None*

#### visibility *: [ModelVisibility](#jaqpotpy.api.openapi.models.model_visibility.ModelVisibility)*

## jaqpotpy.api.openapi.models.model_task module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.model_task.ModelTask(value)

Bases: `str`, `Enum`

#### BINARY_CLASSIFICATION *= 'BINARY_CLASSIFICATION'*

#### MULTICLASS_CLASSIFICATION *= 'MULTICLASS_CLASSIFICATION'*

#### REGRESSION *= 'REGRESSION'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of ModelTask from a JSON string

## jaqpotpy.api.openapi.models.model_type module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.model_type.ModelType(value)

Bases: `str`, `Enum`

#### QSAR_TOOLBOX_CALCULATOR *= 'QSAR_TOOLBOX_CALCULATOR'*

#### QSAR_TOOLBOX_PROFILER *= 'QSAR_TOOLBOX_PROFILER'*

#### QSAR_TOOLBOX_QSAR_MODEL *= 'QSAR_TOOLBOX_QSAR_MODEL'*

#### R_BNLEARN_DISCRETE *= 'R_BNLEARN_DISCRETE'*

#### R_CARET *= 'R_CARET'*

#### R_GBM *= 'R_GBM'*

#### R_NAIVE_BAYES *= 'R_NAIVE_BAYES'*

#### R_PBPK *= 'R_PBPK'*

#### R_RF *= 'R_RF'*

#### R_RPART *= 'R_RPART'*

#### R_SVM *= 'R_SVM'*

#### R_TREE_CLASS *= 'R_TREE_CLASS'*

#### R_TREE_REGR *= 'R_TREE_REGR'*

#### SKLEARN *= 'SKLEARN'*

#### TORCHSCRIPT *= 'TORCHSCRIPT'*

#### TORCH_ONNX *= 'TORCH_ONNX'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of ModelType from a JSON string

## jaqpotpy.api.openapi.models.model_visibility module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.model_visibility.ModelVisibility(value)

Bases: `str`, `Enum`

#### ORG_SHARED *= 'ORG_SHARED'*

#### PRIVATE *= 'PRIVATE'*

#### PUBLIC *= 'PUBLIC'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of ModelVisibility from a JSON string

## jaqpotpy.api.openapi.models.multiclass_classification_scores module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.multiclass_classification_scores.MulticlassClassificationScores(\*, labels: List[Annotated[str, Strict(strict=True)]] | None = None, yName: Annotated[str, Strict(strict=True)], folds: Annotated[int, Strict(strict=True)] | None = None, accuracy: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, balancedAccuracy: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, precision: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, recall: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, f1Score: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, jaccard: Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None, matthewsCorrCoef: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, confusionMatrix: Annotated[List[Annotated[List[Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])] | None = None)

Bases: `BaseModel`

#### accuracy *: StrictFloat | StrictInt | None*

#### balanced_accuracy *: StrictFloat | StrictInt | None*

#### confusion_matrix *: Annotated[List[Annotated[List[StrictFloat | StrictInt], Field(max_length=100)]], Field(max_length=100)] | None*

#### f1_score *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### folds *: StrictInt | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of MulticlassClassificationScores from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of MulticlassClassificationScores from a JSON string

#### jaccard *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### labels *: List[StrictStr] | None*

#### matthews_corr_coef *: StrictFloat | StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'accuracy': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'balanced_accuracy': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='balancedAccuracy', alias_priority=2), 'confusion_matrix': FieldInfo(annotation=Union[Annotated[List[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=100)])], NoneType], required=False, default=None, alias='confusionMatrix', alias_priority=2), 'f1_score': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None, alias='f1Score', alias_priority=2), 'folds': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'jaccard': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'labels': FieldInfo(annotation=Union[List[Annotated[str, Strict(strict=True)]], NoneType], required=False, default=None), 'matthews_corr_coef': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, alias='matthewsCorrCoef', alias_priority=2), 'precision': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'recall': FieldInfo(annotation=Union[Annotated[List[Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)]]], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'y_name': FieldInfo(annotation=str, required=True, alias='yName', alias_priority=2, metadata=[Strict(strict=True)])}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### precision *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### recall *: Annotated[List[StrictFloat | StrictInt], Field(max_length=1000)] | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### y_name *: StrictStr*

## jaqpotpy.api.openapi.models.organization module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.organization.Organization(\*, id: Annotated[int, Strict(strict=True)] | None = None, name: Annotated[str, Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=200)], creator: [User](#jaqpotpy.api.openapi.models.user.User) | None = None, visibility: [OrganizationVisibility](#jaqpotpy.api.openapi.models.organization_visibility.OrganizationVisibility), description: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=2000)])] | None = None, organizationMembers: List[[OrganizationUser](#jaqpotpy.api.openapi.models.organization_user.OrganizationUser)] | None = None, contactEmail: Annotated[str, Strict(strict=True)], contactPhone: Annotated[str, Strict(strict=True)] | None = None, website: Annotated[str, Strict(strict=True)] | None = None, address: Annotated[str, Strict(strict=True)] | None = None, canEdit: Annotated[bool, Strict(strict=True)] | None = None, isMember: Annotated[bool, Strict(strict=True)] | None = None, created_at: datetime | None = None, updated_at: datetime | None = None)

Bases: `BaseModel`

#### address *: StrictStr | None*

#### can_edit *: StrictBool | None*

#### contact_email *: StrictStr*

#### contact_phone *: StrictStr | None*

#### created_at *: datetime | None*

#### creator *: [User](#jaqpotpy.api.openapi.models.user.User) | None*

#### description *: Annotated[str, Field(min_length=3, strict=True, max_length=2000)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Organization from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Organization from a JSON string

#### id *: StrictInt | None*

#### is_member *: StrictBool | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'address': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'can_edit': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, alias='canEdit', alias_priority=2, description='If the current user can edit the organization'), 'contact_email': FieldInfo(annotation=str, required=True, alias='contactEmail', alias_priority=2, metadata=[Strict(strict=True)]), 'contact_phone': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='contactPhone', alias_priority=2), 'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None), 'creator': FieldInfo(annotation=Union[User, NoneType], required=False, default=None), 'description': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=2000)])], NoneType], required=False, default=None), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'is_member': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, alias='isMember', alias_priority=2, description='If the current user is a member of the organization'), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=200)]), 'organization_members': FieldInfo(annotation=Union[List[OrganizationUser], NoneType], required=False, default=None, alias='organizationMembers', alias_priority=2), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None), 'visibility': FieldInfo(annotation=OrganizationVisibility, required=True), 'website': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: Annotated[str, Field(min_length=3, strict=True, max_length=200)]*

#### *classmethod* name_validate_regular_expression(value)

Validates the regular expression

#### organization_members *: List[[OrganizationUser](#jaqpotpy.api.openapi.models.organization_user.OrganizationUser)] | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### updated_at *: datetime | None*

#### visibility *: [OrganizationVisibility](#jaqpotpy.api.openapi.models.organization_visibility.OrganizationVisibility)*

#### website *: StrictStr | None*

## jaqpotpy.api.openapi.models.organization_invitation module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.organization_invitation.OrganizationInvitation(\*, id: Annotated[str, Strict(strict=True)] | None = None, userId: Annotated[str, Strict(strict=True)] | None = None, userEmail: Annotated[str, Strict(strict=True)], status: Annotated[str, Strict(strict=True)], expirationDate: datetime)

Bases: `BaseModel`

#### expiration_date *: datetime*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of OrganizationInvitation from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of OrganizationInvitation from a JSON string

#### id *: StrictStr | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'expiration_date': FieldInfo(annotation=datetime, required=True, alias='expirationDate', alias_priority=2, description='Expiration date of the invitation'), 'id': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='ID of the invitation'), 'status': FieldInfo(annotation=str, required=True, description='Status of the invitation', metadata=[Strict(strict=True)]), 'user_email': FieldInfo(annotation=str, required=True, alias='userEmail', alias_priority=2, description='Email address of the invited user', metadata=[Strict(strict=True)]), 'user_id': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='userId', alias_priority=2, description='The user id associated with that invitation')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### status *: StrictStr*

#### *classmethod* status_validate_enum(value)

Validates the enum

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### user_email *: StrictStr*

#### user_id *: StrictStr | None*

## jaqpotpy.api.openapi.models.organization_summary module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.organization_summary.OrganizationSummary(\*, id: Annotated[int, Strict(strict=True)], name: Annotated[str, Strict(strict=True)])

Bases: `BaseModel`

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of OrganizationSummary from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of OrganizationSummary from a JSON string

#### id *: StrictInt*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'id': FieldInfo(annotation=int, required=True, metadata=[Strict(strict=True)]), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)])}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: StrictStr*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.organization_user module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.organization_user.OrganizationUser(\*, id: Annotated[int, Strict(strict=True)] | None = None, userId: Annotated[str, Strict(strict=True)], username: Annotated[str, Strict(strict=True)] | None = None, email: Annotated[str, Strict(strict=True)] | None = None, associationType: [OrganizationUserAssociationType](#jaqpotpy.api.openapi.models.organization_user_association_type.OrganizationUserAssociationType))

Bases: `BaseModel`

#### association_type *: [OrganizationUserAssociationType](#jaqpotpy.api.openapi.models.organization_user_association_type.OrganizationUserAssociationType)*

#### email *: StrictStr | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of OrganizationUser from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of OrganizationUser from a JSON string

#### id *: StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'association_type': FieldInfo(annotation=OrganizationUserAssociationType, required=True, alias='associationType', alias_priority=2), 'email': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'user_id': FieldInfo(annotation=str, required=True, alias='userId', alias_priority=2, metadata=[Strict(strict=True)]), 'username': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### user_id *: StrictStr*

#### username *: StrictStr | None*

## jaqpotpy.api.openapi.models.organization_user_association_type module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.organization_user_association_type.OrganizationUserAssociationType(value)

Bases: `str`, `Enum`

#### ADMIN *= 'ADMIN'*

#### MEMBER *= 'MEMBER'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of OrganizationUserAssociationType from a JSON string

## jaqpotpy.api.openapi.models.organization_visibility module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.organization_visibility.OrganizationVisibility(value)

Bases: `str`, `Enum`

#### PRIVATE *= 'PRIVATE'*

#### PUBLIC *= 'PUBLIC'*

#### *classmethod* from_json(json_str: str) → Self

Create an instance of OrganizationVisibility from a JSON string

## jaqpotpy.api.openapi.models.partial_update_organization_request module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.partial_update_organization_request.PartialUpdateOrganizationRequest(\*, name: Annotated[str, Strict(strict=True)], description: Annotated[str, Strict(strict=True)] | None = None, contactEmail: Annotated[str, Strict(strict=True)], visibility: [OrganizationVisibility](#jaqpotpy.api.openapi.models.organization_visibility.OrganizationVisibility))

Bases: `BaseModel`

#### contact_email *: StrictStr*

#### description *: StrictStr | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of PartialUpdateOrganizationRequest from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of PartialUpdateOrganizationRequest from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'contact_email': FieldInfo(annotation=str, required=True, alias='contactEmail', alias_priority=2, metadata=[Strict(strict=True)]), 'description': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)]), 'visibility': FieldInfo(annotation=OrganizationVisibility, required=True)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: StrictStr*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### visibility *: [OrganizationVisibility](#jaqpotpy.api.openapi.models.organization_visibility.OrganizationVisibility)*

## jaqpotpy.api.openapi.models.partially_update_model_feature_request module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.partially_update_model_feature_request.PartiallyUpdateModelFeatureRequest(\*, name: Annotated[str, Strict(strict=True), MaxLen(max_length=255)], units: Annotated[str, Strict(strict=True)] | None = None, range: Annotated[str, Strict(strict=True)] | None = None, description: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=2000)])] | None = None, featureType: [FeatureType](#jaqpotpy.api.openapi.models.feature_type.FeatureType), possibleValues: Annotated[List[[FeaturePossibleValue](#jaqpotpy.api.openapi.models.feature_possible_value.FeaturePossibleValue)], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])] | None = None)

Bases: `BaseModel`

#### description *: Annotated[str, Field(strict=True, max_length=2000)] | None*

#### feature_type *: [FeatureType](#jaqpotpy.api.openapi.models.feature_type.FeatureType)*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of PartiallyUpdateModelFeatureRequest from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of PartiallyUpdateModelFeatureRequest from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'description': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=2000)])], NoneType], required=False, default=None), 'feature_type': FieldInfo(annotation=FeatureType, required=True, alias='featureType', alias_priority=2), 'name': FieldInfo(annotation=str, required=True, description='A name for the feature that will appear on top of the form field', metadata=[Strict(strict=True), MaxLen(max_length=255)]), 'possible_values': FieldInfo(annotation=Union[Annotated[List[FeaturePossibleValue], FieldInfo(annotation=NoneType, required=True, metadata=[MaxLen(max_length=1000)])], NoneType], required=False, default=None, alias='possibleValues', alias_priority=2), 'range': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='The range that this feature is using'), 'units': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='The units that this feature is using')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: Annotated[str, Field(strict=True, max_length=255)]*

#### possible_values *: Annotated[List[[FeaturePossibleValue](#jaqpotpy.api.openapi.models.feature_possible_value.FeaturePossibleValue)], Field(max_length=1000)] | None*

#### range *: StrictStr | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### units *: StrictStr | None*

## jaqpotpy.api.openapi.models.partially_update_model_request module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.partially_update_model_request.PartiallyUpdateModelRequest(\*, name: Annotated[str, Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=255)], description: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=50000)])] | None = None, visibility: [ModelVisibility](#jaqpotpy.api.openapi.models.model_visibility.ModelVisibility), task: [ModelTask](#jaqpotpy.api.openapi.models.model_task.ModelTask), tags: Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=1000)])] | None = None, sharedWithOrganizationIds: List[Annotated[int, Strict(strict=True)]] | None = None)

Bases: `BaseModel`

#### description *: Annotated[str, Field(min_length=3, strict=True, max_length=50000)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of PartiallyUpdateModelRequest from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of PartiallyUpdateModelRequest from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'description': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=50000)])], NoneType], required=False, default=None), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True), MinLen(min_length=3), MaxLen(max_length=255)]), 'shared_with_organization_ids': FieldInfo(annotation=Union[List[Annotated[int, Strict(strict=True)]], NoneType], required=False, default=None, alias='sharedWithOrganizationIds', alias_priority=2), 'tags': FieldInfo(annotation=Union[Annotated[str, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), MaxLen(max_length=1000)])], NoneType], required=False, default=None), 'task': FieldInfo(annotation=ModelTask, required=True), 'visibility': FieldInfo(annotation=ModelVisibility, required=True)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: Annotated[str, Field(min_length=3, strict=True, max_length=255)]*

#### shared_with_organization_ids *: List[StrictInt] | None*

#### tags *: Annotated[str, Field(strict=True, max_length=1000)] | None*

#### task *: [ModelTask](#jaqpotpy.api.openapi.models.model_task.ModelTask)*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### visibility *: [ModelVisibility](#jaqpotpy.api.openapi.models.model_visibility.ModelVisibility)*

## jaqpotpy.api.openapi.models.prediction_doa module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.prediction_doa.PredictionDoa(\*, id: Annotated[int, Strict(strict=True)] | None = None, method: [DoaMethod](#jaqpotpy.api.openapi.models.doa_method.DoaMethod), data: Dict[str, Any], createdAt: datetime | None = None, updatedAt: datetime | None = None)

Bases: `BaseModel`

#### created_at *: datetime | None*

#### data *: Dict[str, Any]*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of PredictionDoa from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of PredictionDoa from a JSON string

#### id *: StrictInt | None*

#### method *: [DoaMethod](#jaqpotpy.api.openapi.models.doa_method.DoaMethod)*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'created_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='createdAt', alias_priority=2, description='The date and time when the feature was created.'), 'data': FieldInfo(annotation=Dict[str, Any], required=True, description='The doa calculated data'), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'method': FieldInfo(annotation=DoaMethod, required=True), 'updated_at': FieldInfo(annotation=Union[datetime, NoneType], required=False, default=None, alias='updatedAt', alias_priority=2, description='The date and time when the feature was last updated.')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### updated_at *: datetime | None*

## jaqpotpy.api.openapi.models.prediction_model module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.prediction_model.PredictionModel(\*, id: Annotated[int, Strict(strict=True)] | None = None, dependentFeatures: List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)], independentFeatures: List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)], type: [ModelType](#jaqpotpy.api.openapi.models.model_type.ModelType), rawModel: Annotated[str, Strict(strict=True)], rawPreprocessor: Annotated[str, Strict(strict=True)] | None = None, doas: List[[PredictionDoa](#jaqpotpy.api.openapi.models.prediction_doa.PredictionDoa)] | None = None, selectedFeatures: List[Annotated[str, Strict(strict=True)]] | None = None, task: [ModelTask](#jaqpotpy.api.openapi.models.model_task.ModelTask), featurizers: List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)] | None = None, preprocessors: List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)] | None = None, torchConfig: Dict[str, Any] | None = None, legacyAdditionalInfo: Dict[str, Any] | None = None, legacyPredictionService: Annotated[str, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### dependent_features *: List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)]*

#### doas *: List[[PredictionDoa](#jaqpotpy.api.openapi.models.prediction_doa.PredictionDoa)] | None*

#### featurizers *: List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)] | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of PredictionModel from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of PredictionModel from a JSON string

#### id *: StrictInt | None*

#### independent_features *: List[[Feature](#jaqpotpy.api.openapi.models.feature.Feature)]*

#### legacy_additional_info *: Dict[str, Any] | None*

#### legacy_prediction_service *: StrictStr | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'dependent_features': FieldInfo(annotation=List[Feature], required=True, alias='dependentFeatures', alias_priority=2, description='List of dependent features for the model'), 'doas': FieldInfo(annotation=Union[List[PredictionDoa], NoneType], required=False, default=None, description='List of Domain of Applicability (DoA) configurations'), 'featurizers': FieldInfo(annotation=Union[List[Transformer], NoneType], required=False, default=None, description='List of featurizer configurations applied to the model'), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None, description='Unique identifier for the prediction model'), 'independent_features': FieldInfo(annotation=List[Feature], required=True, alias='independentFeatures', alias_priority=2, description='List of independent features for the model'), 'legacy_additional_info': FieldInfo(annotation=Union[Dict[str, Any], NoneType], required=False, default=None, alias='legacyAdditionalInfo', alias_priority=2, description='Legacy additional information settings, optional'), 'legacy_prediction_service': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='legacyPredictionService', alias_priority=2, description='Legacy prediction service information, if available'), 'preprocessors': FieldInfo(annotation=Union[List[Transformer], NoneType], required=False, default=None, description='List of preprocessor configurations applied to the model'), 'raw_model': FieldInfo(annotation=str, required=True, alias='rawModel', alias_priority=2, description='Raw model data in serialized format', metadata=[Strict(strict=True)]), 'raw_preprocessor': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='rawPreprocessor', alias_priority=2, description='Raw preprocessor data in serialized format'), 'selected_features': FieldInfo(annotation=Union[List[Annotated[str, Strict(strict=True)]], NoneType], required=False, default=None, alias='selectedFeatures', alias_priority=2, description='List of feature names selected for the model'), 'task': FieldInfo(annotation=ModelTask, required=True), 'torch_config': FieldInfo(annotation=Union[Dict[str, Any], NoneType], required=False, default=None, alias='torchConfig', alias_priority=2, description='Torch configuration settings, optional'), 'type': FieldInfo(annotation=ModelType, required=True)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### preprocessors *: List[[Transformer](#jaqpotpy.api.openapi.models.transformer.Transformer)] | None*

#### raw_model *: StrictStr*

#### raw_preprocessor *: StrictStr | None*

#### selected_features *: List[StrictStr] | None*

#### task *: [ModelTask](#jaqpotpy.api.openapi.models.model_task.ModelTask)*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### torch_config *: Dict[str, Any] | None*

#### type *: [ModelType](#jaqpotpy.api.openapi.models.model_type.ModelType)*

## jaqpotpy.api.openapi.models.prediction_request module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.prediction_request.PredictionRequest(\*, model: [PredictionModel](#jaqpotpy.api.openapi.models.prediction_model.PredictionModel), dataset: [Dataset](#jaqpotpy.api.openapi.models.dataset.Dataset))

Bases: `BaseModel`

#### dataset *: [Dataset](#jaqpotpy.api.openapi.models.dataset.Dataset)*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of PredictionRequest from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of PredictionRequest from a JSON string

#### model *: [PredictionModel](#jaqpotpy.api.openapi.models.prediction_model.PredictionModel)*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'dataset': FieldInfo(annotation=Dataset, required=True), 'model': FieldInfo(annotation=PredictionModel, required=True)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.prediction_response module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.prediction_response.PredictionResponse(\*, predictions: List[Any])

Bases: `BaseModel`

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of PredictionResponse from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of PredictionResponse from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'predictions': FieldInfo(annotation=List[Any], required=True)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### predictions *: List[Any]*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.regression_scores module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.regression_scores.RegressionScores(\*, yName: Annotated[str, Strict(strict=True)], folds: Annotated[int, Strict(strict=True)] | None = None, r2: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, mae: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None, rmse: Annotated[float, Strict(strict=True)] | Annotated[int, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### folds *: StrictInt | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of RegressionScores from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of RegressionScores from a JSON string

#### mae *: StrictFloat | StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'folds': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'mae': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'r2': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'rmse': FieldInfo(annotation=Union[Annotated[float, Strict(strict=True)], Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'y_name': FieldInfo(annotation=str, required=True, alias='yName', alias_priority=2, metadata=[Strict(strict=True)])}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### r2 *: StrictFloat | StrictInt | None*

#### rmse *: StrictFloat | StrictInt | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### y_name *: StrictStr*

## jaqpotpy.api.openapi.models.scores module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.scores.Scores(\*, regression: [RegressionScores](#jaqpotpy.api.openapi.models.regression_scores.RegressionScores) | None = None, binaryClassification: [BinaryClassificationScores](#jaqpotpy.api.openapi.models.binary_classification_scores.BinaryClassificationScores) | None = None, multiclassClassification: [MulticlassClassificationScores](#jaqpotpy.api.openapi.models.multiclass_classification_scores.MulticlassClassificationScores) | None = None)

Bases: `BaseModel`

#### binary_classification *: [BinaryClassificationScores](#jaqpotpy.api.openapi.models.binary_classification_scores.BinaryClassificationScores) | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Scores from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Scores from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'binary_classification': FieldInfo(annotation=Union[BinaryClassificationScores, NoneType], required=False, default=None, alias='binaryClassification', alias_priority=2), 'multiclass_classification': FieldInfo(annotation=Union[MulticlassClassificationScores, NoneType], required=False, default=None, alias='multiclassClassification', alias_priority=2), 'regression': FieldInfo(annotation=Union[RegressionScores, NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### multiclass_classification *: [MulticlassClassificationScores](#jaqpotpy.api.openapi.models.multiclass_classification_scores.MulticlassClassificationScores) | None*

#### regression *: [RegressionScores](#jaqpotpy.api.openapi.models.regression_scores.RegressionScores) | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.transformer module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.transformer.Transformer(\*, id: Annotated[int, Strict(strict=True)] | None = None, name: Annotated[str, Strict(strict=True)], config: Dict[str, Any])

Bases: `BaseModel`

A preprocessor for the model

#### config *: Dict[str, Any]*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of Transformer from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of Transformer from a JSON string

#### id *: StrictInt | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'config': FieldInfo(annotation=Dict[str, Any], required=True), 'id': FieldInfo(annotation=Union[Annotated[int, Strict(strict=True)], NoneType], required=False, default=None), 'name': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)])}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### name *: StrictStr*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.update_api_key200_response module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.update_api_key200_response.UpdateApiKey200Response(\*, key: Annotated[str, Strict(strict=True)] | None = None, note: Annotated[str, Strict(strict=True)] | None = None, enabled: Annotated[bool, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### enabled *: StrictBool | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of UpdateApiKey200Response from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of UpdateApiKey200Response from a JSON string

#### key *: StrictStr | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'enabled': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, description='Whether the API key is active or disabled'), 'key': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='The updated API key'), 'note': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='The updated description of the API key')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### note *: StrictStr | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.update_api_key_request module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.update_api_key_request.UpdateApiKeyRequest(\*, note: Annotated[str, Strict(strict=True)] | None = None, enabled: Annotated[bool, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### enabled *: StrictBool | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of UpdateApiKeyRequest from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of UpdateApiKeyRequest from a JSON string

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'enabled': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, description='Set to \`false\` to disable the API key'), 'note': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, description='Updated description for the API key')}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### note *: StrictStr | None*

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

## jaqpotpy.api.openapi.models.user module

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.

### *class* jaqpotpy.api.openapi.models.user.User(\*, id: Annotated[str, Strict(strict=True)], username: Annotated[str, Strict(strict=True)] | None = None, firstName: Annotated[str, Strict(strict=True)] | None = None, lastName: Annotated[str, Strict(strict=True)] | None = None, email: Annotated[str, Strict(strict=True)] | None = None, emailVerified: Annotated[bool, Strict(strict=True)] | None = None)

Bases: `BaseModel`

#### email *: StrictStr | None*

#### email_verified *: StrictBool | None*

#### first_name *: StrictStr | None*

#### *classmethod* from_dict(obj: Dict[str, Any] | None) → Self | None

Create an instance of User from a dict

#### *classmethod* from_json(json_str: str) → Self | None

Create an instance of User from a JSON string

#### id *: StrictStr*

#### last_name *: StrictStr | None*

#### model_computed_fields *: ClassVar[dict[str, ComputedFieldInfo]]* *= {}*

A dictionary of computed field names and their corresponding ComputedFieldInfo objects.

#### model_config *: ClassVar[ConfigDict]* *= {'populate_by_name': True, 'protected_namespaces': (), 'validate_assignment': True}*

Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].

#### model_fields *: ClassVar[dict[str, FieldInfo]]* *= {'email': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None), 'email_verified': FieldInfo(annotation=Union[Annotated[bool, Strict(strict=True)], NoneType], required=False, default=None, alias='emailVerified', alias_priority=2), 'first_name': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='firstName', alias_priority=2), 'id': FieldInfo(annotation=str, required=True, metadata=[Strict(strict=True)]), 'last_name': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None, alias='lastName', alias_priority=2), 'username': FieldInfo(annotation=Union[Annotated[str, Strict(strict=True)], NoneType], required=False, default=None)}*

Metadata about the fields defined on the model,
mapping of field names to [FieldInfo][pydantic.fields.FieldInfo].

This replaces Model._\_fields_\_ from Pydantic V1.

#### model_post_init(\_\_context: Any) → None

This function is meant to behave like a BaseModel method to initialise private attributes.

It takes context as an argument since that’s what pydantic-core passes when calling it.

Args:
: self: The BaseModel instance.
  \_\_context: The context.

#### to_dict() → Dict[str, Any]

Return the dictionary representation of the model using alias.

This has the following differences from calling pydantic’s
self.model_dump(by_alias=True):

* None is only added to the output dict for nullable fields that
  were set at model initialization. Other fields with value None
  are ignored.

#### to_json() → str

Returns the JSON representation of the model using alias

#### to_str() → str

Returns the string representation of the model using alias

#### username *: StrictStr | None*

## Module contents

Jaqpot API

A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.

The version of the OpenAPI document: 1.0.0
Contact: [upci.ntua@gmail.com](mailto:upci.ntua@gmail.com)
Generated by OpenAPI Generator ([https://openapi-generator.tech](https://openapi-generator.tech))

Do not edit the class manually.
